/// <reference types="node" />
import { Location, Selector, MessagePackage, ReplyPackage, DispatchHandler, HubMessage, ClientOptions } from '../types';
import { MessengerClient } from '@pandorajs/messenger';
import { EventEmitter } from 'events';
export declare class HubClient extends EventEmitter {
    protected messengerClient: MessengerClient;
    protected location: Location;
    protected publishedSelectors: Array<Selector>;
    protected logger: any;
    protected dispatchHandlers: DispatchHandler[];
    constructor(options: ClientOptions);
    /**
     * Set a handler to hand HUB Dispatching message
     * @param {DispatchHandler} dispatchHandler
     */
    pushDispatchHandler(dispatchHandler: DispatchHandler): void;
    handleHubDispatch(message: HubMessage): Promise<any>;
    isReady(): boolean;
    /**
     * Let this client online
     * @return {Promise<void>}
     */
    start(): Promise<void>;
    protected sendOnline(): Promise<void>;
    /**
     * Publish a selector to Hub, so Hub will set a relation in RouteTable between client and selector
     * @param {Selector} selector
     * @return {Promise<ReplyPackage>}
     */
    publish(selector: Selector): Promise<ReplyPackage>;
    /**
     * Unpublish a selector to Hub, so Hub will forget the relation in RouteTable between client and selector
     * @param {Selector} selector
     * @return {Promise<ReplyPackage>}
     */
    unpublish(selector: Selector): Promise<ReplyPackage>;
    /**
     * Resend all published selectors to HUB when reconnected
     * @return {Promise<void>}
     */
    protected resendPublishedSelectors(): Promise<void>;
    /**
     * Invoke a remote Object only from a random one of all selected clients
     * @return {Promise<any>}
     */
    invoke(remote: Selector, action: any, message: any): Promise<ReplyPackage>;
    /**
     * Invoke a remote Object from all selected clients
     * @param {Selector} remote
     * @param message
     * @return {Promise<Array<ReplyPackage>>}
     */
    multipleInvoke(remote: Selector, action: any, message: any): Promise<Array<ReplyPackage>>;
    /**
     * Send a message to a random one of all selected clients
     * @param remote
     * @param data
     * @return {Promise<void>}
     */
    send(remote: Selector, action: any, message: any): void;
    /**
     * Send a message to all selected clients
     * @param remote
     * @param message
     * @return {Promise<void>}
     */
    multipleSend(remote: Selector, action: any, message: any): void;
    /**
     * Get location of this client
     * @return {Location}
     */
    getLocation(): Location;
    /**
     * Send a message to Hub
     */
    protected sendToHub<MessageType extends MessagePackage>(action: any, message?: MessageType): void;
    /**
     * Send a message to Hub and wait reply
     * @param action
     * @param {MessageType} message
     * @return {Promise<ReplyPackage>}
     */
    protected sendToHubAndWaitReply<MessageType extends MessagePackage>(action: any, message?: MessageType): Promise<ReplyPackage>;
    /**
     * only send publish message to Hub without state keeping
     * @param {Selector} selector
     * @return {Promise<ReplyPackage>}
     */
    protected sendPublishToHub(selector: Selector): Promise<ReplyPackage>;
    /**
     * Make sure each selector are unique
     * @param selector
     */
    protected assertExistSelector(selector: any): void;
    startListen(): void;
    /**
     * Close this client
     */
    stop(): Promise<void>;
    getMessengerClient(): MessengerClient;
}
//# sourceMappingURL=HubClient.d.ts.map