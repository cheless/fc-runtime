/// <reference types="node" />
import MessengerBase from './base';
export default class Client extends MessengerBase {
    private _reConnectTimes;
    private _socket;
    private _header;
    private _bodyLength;
    private _queue;
    private _packetId;
    private _unref;
    /**
     * tcp 客户端的基类
     * @param {Object} options
     *   - {Number} headerLength - 通讯协议头部长度, 可选， 不传的话就必须实现getHeader方法
     *   - {Boolean} [noDelay] - 是否开启 Nagle 算法，默认：true，不开启
     *   - {Boolean} [unref] - socket.unref，默认不 false
     *   - {Number} [concurrent] - 并发请求数，默认：0，不控制并发
     *   - {Number} [responseTimeout] - 请求超时
     *   - {Number} [reConnectTimes] - 自动最大重连次数，默认：0，不自动重连，当重连次数超过此值时仍然无法连接就触发close error事件
     *   - {Number} [reConnectInterval] - 重连时间间隔，默认： 1s，当reConnectTimes大于0时才有效
     * @constructor
     */
    constructor(options: any);
    createPacketId(): number;
    /**
     * 读取 packet 的头部
     * @return {Buffer} header
     */
    getHeader(): any;
    /**
     * 根据头部信息获取 body 的长度
     * @param {Buffer} header - 头部数据
     * @return {Number} bodyLength
     */
    getBodyLength(header: any): any;
    /**
     * 反序列化
     * @param {Buffer} buf - 二进制数据
     * @return {Object} 对象
     */
    decode(buf: any, header: any): {
        oneway: boolean;
        isResponse: boolean;
        id: any;
        data: any;
    };
    /**
     * 序列化消息
     * @param {Buffer} buf - 二进制数据
     * @return {Object} 对象
     */
    encode(message: any): Buffer;
    /**
     * 当前socket是否可写
     * @property {Boolean} TCPBase#_writable
     */
    get _writable(): boolean;
    /**
     * 连接是否正常
     * @property {Boolean} TCPBase#isOK
     */
    get isOK(): boolean;
    get shouldUnref(): boolean;
    /**
     * 从socket缓冲区中读取n个buffer
     * @param {Number} n - buffer长度
     * @return {Buffer} - 读取到的buffer
     */
    read(n: any): any;
    send(action: any, data: any, callback?: any, timeout?: any): void;
    /**
     * 发送数据
     * @param {Object} packet
     *   - {Number} id - packet id
     *   - {Buffer} data - 发送的二进制数据
     *   - {Boolean} [oneway] - 是否单向
     *   - {Number} [timeout] - 请求超时时长
     * @param {Function} [callback] - 回调函数，可选
     * @return {void}
     */
    _send(packet: any, callback?: any): void;
    _cleanQueue(): void;
    _resume(): void;
    _readPacket(): boolean;
    /**
     * 主动关闭连接
     * @return {void}
     */
    close(): void;
    /**
     * 关闭连接
     * @param {Error} err - 导致关闭连接的异常
     * @return {void}
     */
    _close(err?: any): void;
    _handleClose(err?: Error): void;
    _connect(done?: () => void): void;
    _bind(): void;
}
//# sourceMappingURL=client.d.ts.map