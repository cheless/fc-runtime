"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreSDK = void 0;
const os = require("os");
const path = require("path");
const extend = require("extend");
const component_decorator_1 = require("@pandorajs/component-decorator");
const ComponentWeightCalculator_1 = require("./ComponentWeightCalculator");
const defaultConfig = require("./pandoraConfig");
const path_1 = require("path");
const resources_1 = require("@opentelemetry/resources");
const dollar_1 = require("@pandorajs/dollar");
const resolve = require('resolve');
const debug = require('debug')('pandora:CoreSDK');
class CoreSDK {
    constructor(options) {
        this.components = new Map();
        this.componentInstances = new Map();
        this.instantiated = false;
        this.options = options;
        // TODO: pandora version detection.
        let resource = resources_1.Resource.createTelemetrySDKResource();
        if (options.resource) {
            resource = resource.merge(options.resource);
        }
        this.coreContext = {
            mode: options.mode,
            appName: options.appName,
            processName: options.processName || options.mode,
            resource,
            config: {},
            logger: dollar_1.consoleLogger,
        };
        debug('constructing CoreSDK %j', options);
        if (this.options.extendContext) {
            Object.assign(this.coreContext, this.options.extendContext);
        }
        this.loadConfig(defaultConfig, __dirname);
    }
    get config() {
        return this.coreContext.config;
    }
    set config(newConfig) {
        this.coreContext.config = newConfig;
    }
    instantiate() {
        if (this.instantiated) {
            return;
        }
        this.loadConfigFromDefaultPlaces();
        this.loadComponentsFromConfig();
        const startQueue = this.getStartQueue();
        for (const { name } of startQueue) {
            this.getInstance(name);
        }
        this.instantiated = true;
    }
    async start() {
        this.instantiate();
        if (this.coreContext.mode === 'supervisor') {
            return this.startAtSupervisor();
        }
        return this.startAtWorker();
    }
    async startAtWorker() {
        const startQueue = this.getStartQueue();
        for (const { name } of startQueue) {
            const instance = this.getInstance(name);
            if (instance.start) {
                await instance.start();
                debug(`started component ${name} at worker`);
            }
        }
    }
    async startAtSupervisor() {
        const startQueue = this.getStartQueue();
        for (const { name } of startQueue) {
            const instance = this.getInstance(name);
            if (instance.startAtSupervisor) {
                await instance.startAtSupervisor();
                debug(`started component ${name} at supervisor`);
            }
        }
    }
    async stop() {
        if (this.coreContext.mode === 'supervisor') {
            return this.stopAtSupervisor();
        }
        return this.stopAtWorker();
    }
    async stopAtWorker() {
        const stopQueue = this.getStopQueue();
        for (const { name } of stopQueue) {
            const instance = this.getInstance(name);
            if (instance.stop) {
                await instance.stop();
                debug(`stopped component ${name} at worker`);
            }
        }
    }
    async stopAtSupervisor() {
        const stopQueue = this.getStopQueue();
        for (const { name } of stopQueue) {
            const instance = this.getInstance(name);
            if (instance.stopAtSupervisor) {
                await instance.stopAtSupervisor();
                debug(`stopped component ${name} at supervisor`);
            }
        }
    }
    getInstance(name) {
        if (!this.componentInstances.has(name)) {
            const componentDeclaration = this.components.get(name);
            const { klass: Klass } = componentDeclaration;
            const instance = new Klass(this.coreContext);
            this.componentInstances.set(name, instance);
        }
        return this.componentInstances.get(name);
    }
    getStartQueue() {
        const calculator = new ComponentWeightCalculator_1.ComponentWeightCalculator(this.components);
        return calculator.getSortedComponentNames('asc');
    }
    getStopQueue() {
        const calculator = new ComponentWeightCalculator_1.ComponentWeightCalculator(this.components);
        return calculator.getSortedComponentNames('desc');
    }
    loadConfigFromDefaultPlaces() {
        const configLoadDirs = ['/etc/', os.homedir(), process.cwd()];
        for (const dir of configLoadDirs) {
            try {
                const target = path.join(dir, 'pandoraConfig');
                const extConfig = require(target);
                this.loadConfig(extConfig, dir);
            }
            catch (err) {
                // ignore
            }
        }
        if (this.options.extendConfig) {
            for (const { config, configDir } of this.options.extendConfig) {
                this.loadConfig(config, configDir);
            }
        }
    }
    loadConfig(extConfig, configDir, reverseExtend = false) {
        debug('loadConfig configDir %s, config %j', configDir, extConfig);
        const components = extConfig.components;
        if (components) {
            for (const comp of Object.values(components)) {
                comp.configDir = configDir;
            }
        }
        if (reverseExtend) {
            this.config = extend(true, extConfig, this.config);
        }
        else {
            extend(true, this.config, extConfig);
        }
    }
    loadComponentsFromConfig() {
        const components = this
            .config.components;
        for (const name of Object.keys(components)) {
            const { path, configDir } = components[name];
            const resolvedPath = resolve.sync(path, {
                basedir: configDir,
                extensions: ['.js', '.ts'],
            });
            let klass = require(resolvedPath);
            klass = klass.default ? klass.default : klass;
            const dependencies = component_decorator_1.ComponentReflector.getDependencies(klass) || [];
            const metaName = component_decorator_1.ComponentReflector.getComponentName(klass);
            const componentDefaultConfig = component_decorator_1.ComponentReflector.getComponentConfig(klass);
            if (metaName && metaName !== name) {
                throw new Error(`Component decorated name ${metaName}, but config name is ${name}`);
            }
            if (componentDefaultConfig) {
                this.loadConfig(componentDefaultConfig, path_1.dirname(resolvedPath), true);
            }
            this.addComponent({ name, path, klass, dependencies });
        }
    }
    addComponent(component) {
        debug(`addComponent ${component.name}`);
        this.components.set(component.name, component);
    }
}
exports.CoreSDK = CoreSDK;
//# sourceMappingURL=CoreSDK.js.map