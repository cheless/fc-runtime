'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const is = require("is-type-of");
const net = require("net");
const fs = require("fs");
const base_1 = require("./base");
const client_1 = require("./client");
const eventName_1 = require("./eventName");
const debug = require('debug')('pandora:messenger:server');
class Server extends base_1.default {
    constructor(options) {
        super(options);
        this.clients = new Map();
        this.server = net.createServer(this._handleConnection.bind(this));
        this.server.on('error', this._throwError.bind(this));
        this.listen();
    }
    listen(callback) {
        const sockPath = this.sockPath;
        if (fs.existsSync(sockPath)) {
            fs.unlinkSync(sockPath);
        }
        this.server.listen(sockPath, () => {
            debug(`[server] pandora messenger server is listening, socket path is ${this.sockPath}!`);
            setImmediate(() => {
                this.ready(true);
                if (is.function(callback)) {
                    callback();
                }
            });
        });
        return this;
    }
    broadcast(action, data) {
        return this._broadcast({
            action: action,
            data: data,
        });
    }
    _broadcast(info) {
        if (this.clients.size === 0) {
            if (!this.pending) {
                this.pending = [];
                this.on('connected', client => {
                    this.pending.forEach(msg => {
                        client.send(msg.action, msg.data);
                    });
                });
            }
            this.pending.push(info);
            return this;
        }
        for (const sock of this.clients.keys()) {
            this.clients.get(sock).send(info.action, info.data);
        }
        return this;
    }
    close(callback) {
        for (const sock of this.clients.keys()) {
            const client = this.clients.get(sock);
            client.close();
            this.clients.delete(sock);
        }
        this.server.removeAllListeners();
        this.server.close(callback);
        return this;
    }
    _handleMessage(message, reply, client) {
        this.emit(eventName_1.default, message, reply, client);
    }
    _handleDisconnect(socket) {
        debug('[server] server lost a connection!');
        const client = this.clients.get(socket);
        this.clients.delete(socket);
        this.emit('disconnected', client);
    }
    _handleConnection(socket) {
        debug('[server] server got a connection!');
        const client = new client_1.default({
            socket: socket,
            name: this.options.name,
        });
        this.clients.set(socket, client);
        client.on(eventName_1.default, (message, reply) => {
            this._handleMessage(message, reply, client);
        });
        client.on('error', this._throwError.bind(this));
        socket.on('close', this._handleDisconnect.bind(this, socket));
        this.emit('connected', client);
    }
}
exports.default = Server;
//# sourceMappingURL=server.js.map